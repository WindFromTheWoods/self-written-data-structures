/*
 * Лист - Это структура данных, которая содержит в себе элемент (узел) и указатель на последующий элемент
 * Последний элемент листа указывает на nullptr (Нулевой указатель)
 *
 * Что бы реализовать односвязный список нам необходимо:
 * 1) Выделить под него память.
 * 2) Задать ему значение
 * 3) Сделать так, чтобы он ссылался на предыдущий элемент (или на NULL, если его не было)
 * 4) Перекинуть указатель head на новый узел.
 */

#include <iostream>
using namespace std;

// Узел между обьектами листа
typedef struct Node
{
    int value;
    struct Node *next;
} Node;

// В самом начале списка не существует по этому мы указываем на nullprt
Node *head = nullptr;

/*
 * Обьявляем функцию push, она должна:
 * 1) Выделить память для записи
 * 2) Добавлять значение в начало списка
 */
void push(Node **head, int dataq);

/*
 * Обьявляем функцию pop, она должна:
 * 1) Удалять указатель на первый элемент
 * 2) Возвращать значение
 */
void pop();

void pushBack();

void popBack();

// Мейн функция
int main() {}

// Реализация функции push
void push(Node **head, int data)
{
    Node *tmp = (Node*) malloc(sizeof(Node));   // Выделяем память для элемента и создаем новый узел
    if(tmp == NULL)                                  // Проверяем была ли выделена память
    {
        exit(-1);                              // Выходим из функции, если у нас не была выделена память
    }
    tmp->value = data;                               // Записываем значение
    tmp->next = *head;                               // Указатель на предыдущий узел
    *head = tmp;                                     // Присваиваем указатель на адрес нового узла
}

// Реализация функции pop
int pop(Node **head) {                      // Так как head изменяется в процессе, указываем указатель на него
    if (head == NULL || *head == NULL)      // Проверяем есть ли у нас элемент в листе
    {
        exit(-1);                     // Выходим из функции, если у нас нету элемента в листе
    }
    int val = (*head)->value;               // Обьявляем пременную и записываем значение которое хранилось в листе
    Node* temp = *head;                     // Локальная переменная, которая хранит адрес первого обьекта
    *head = (*head)->next;                  // Запись адреса первого обьекта
    free(temp);                     // Удалили узел и освободили память
    return val;                             // Вернули значение
}

// Реализация функии pushBack
void pushBack()
{

}

// Реализация функии popBack
int popBack()
{

}